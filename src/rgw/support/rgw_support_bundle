#!/usr/bin/env python3

# CORTX Python common library.
# Copyright (c) 2022 Seagate Technology LLC and/or its Affiliates
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
# For any questions about this software or licensing,
# please email opensource@seagate.com or cortx-questions@seagate.com.

import sys
import os
import re
import glob
import shutil
import tarfile
import errno
import argparse

from cortx.utils.log import Log
from cortx.utils.errors import BaseError
from cortx.utils.process import SimpleProcess
from cortx.utils.conf_store.conf_store import Conf, MappedConf
from cortx.utils.support_framework.log_filters import FilterLog
from cortx.rgw.const import (
    CONFIG_PATH_KEY, LOG_PATH_KEY, COMPONENT_NAME, RGW_CONF_FILE, RGW_CORE_FILE_DIR_NAME)


class SupportBundleError(BaseError):
    """ SupportBundleError exception with error code and output """

    def __init__(self, rc, message, *args):
        super().__init__(rc, message, *args)


class RGWSupportBundle:
    """Generate rgw specific support bundle."""
    _tmp_src = '/tmp/rgw/'

    @staticmethod
    def generate(bundle_id: str, target_path: str, cluster_conf: str, **filters):
        """ Generate a tar file. """
        Log.info(f"{COMPONENT_NAME} support bundle generation started!!")
        coredumps = filters.get('coredumps', False)
        stacktrace = filters.get('stacktrace', False)
        duration = filters.get('duration',False)
        size_limit = filters.get('size_limit')
        machine_id = Conf.machine_id
        cortx_config_store = MappedConf(cluster_conf)
        log_base = cortx_config_store.get(LOG_PATH_KEY)
        config_path = cortx_config_store.get(CONFIG_PATH_KEY)
        config_dir = os.path.join(config_path, COMPONENT_NAME, machine_id)
        config_file = os.path.join(config_dir, RGW_CONF_FILE)

        if os.path.exists(RGWSupportBundle._tmp_src):
            RGWSupportBundle._cleanup()
        os.makedirs(RGWSupportBundle._tmp_src, exist_ok=True)
        # copy configuration files
        if os.path.exists(config_file):
            shutil.copyfile(config_file,\
                os.path.join(RGWSupportBundle._tmp_src, RGW_CONF_FILE))
        else:
            Log.error(f"{config_file} is not present."
                      f"Skipping the config file collection for {COMPONENT_NAME}")

        # copy rgw client log files
        log_dir = os.path.join(log_base, f'rgw/{machine_id}')
        if os.path.exists(log_dir):
            regex = re.compile('(rgw*)|(radosgw*)')
            for file in os.listdir(log_dir):
                if regex.match(file):
                    infile = os.path.join(log_dir, file)
                    outfile = os.path.join(RGWSupportBundle._tmp_src, file)
                    if os.path.isfile(infile):
                        shutil.copyfile(infile, outfile)

        if duration:
            # files in delim_space use timestamp syntax as
            # [2022-07-10 05:26:57,579] & 2022-07-10 05:26:34
            # files in delim_T use timestamp syntax as
            # 2022-07-10T05:28:35.570+0000
            from cortx.utils.support_framework.log_filters import FilterLog
            from cortx.rgw.const import ( RGW_STARTUP_LOG, RGW_SETUP_LOG,
                RGW_SUPPORT_BUNDLE_LOG, RADOSGW_ADMIN_LOG, RGW_1_LOG,
                LOG_DATE_REGEX, LOG_TIME_REGEX, DATETIME_DATE_REGEX,
                DATETIME_TIME_REGEX)

            # log files with timestamp syntax "YYYY-mm-DD H:M:S"
            delim_space = [RGW_STARTUP_LOG, RGW_SETUP_LOG, RGW_SUPPORT_BUNDLE_LOG]
            # log files with timestamp syntax "YYYY-mm-DDTH:M:S"
            delim_T = [RADOSGW_ADMIN_LOG, RGW_1_LOG]
            for file in os.listdir(RGWSupportBundle._tmp_src):
                if file in delim_space:
                    delim = ' '
                elif file in delim_T:
                    delim = 'T'
                else:
                    continue
                log_timestamp_regex = LOG_DATE_REGEX + delim + LOG_TIME_REGEX
                datetime_format = DATETIME_DATE_REGEX + delim + DATETIME_TIME_REGEX
                # apply log filter to individual file by passing exact filename
                # to file_name_reg_ex
                FilterLog.limit_time(
                    src_dir=RGWSupportBundle._tmp_src,
                    dest_dir=RGWSupportBundle._tmp_src,
                    duration=duration,
                    file_name_reg_ex=file,
                    log_timestamp_regex=log_timestamp_regex,
                    datetime_format=datetime_format)

        else:
            Log.error("RGW log file does not exists hence skipping log file collection.")

        # remaining size limit in folder
        remaining_size_limit = RGWSupportBundle._get_remaining_folder_size(
            RGWSupportBundle._tmp_src, size_limit)
        # apply truncate logic on all textual logs
        if size_limit:
            from cortx.utils.support_framework.log_filters import FilterLog
            tmp_path_for_copy = os.path.join(RGWSupportBundle._tmp_src, 'tmp_dir')
            FilterLog.limit_size(
                src_dir=RGWSupportBundle._tmp_src,
                dest_dir= tmp_path_for_copy,
                size=remaining_size_limit,
                file_name_reg_ex='rgw*')
            remaining_size_limit = RGWSupportBundle._get_remaining_folder_size(
                RGWSupportBundle._tmp_src, size_limit)
            FilterLog.limit_size(
                src_dir=RGWSupportBundle._tmp_src,
                dest_dir= tmp_path_for_copy,
                size=remaining_size_limit,
                file_name_reg_ex='radosgw*')

            for file in os.listdir(tmp_path_for_copy):
                shutil.move(os.path.join(tmp_path_for_copy, file),
                os.path.join(RGWSupportBundle._tmp_src, file))
            shutil.rmtree(tmp_path_for_copy)

        # copy addb logs
        addb_log_path = os.path.join(log_dir, 'addb_files-*')
        addb_dirs = glob.glob(addb_log_path)
        for addb_dir in addb_dirs:
            shutil.copytree(addb_dir,
                os.path.join(RGWSupportBundle._tmp_src, addb_dir.split('/')[-1]))

        # copy motr trace log files
        motr_trace_dir = os.path.join(log_dir, 'motr_trace_files')
        if os.path.exists(motr_trace_dir):
            # include the latest 5 log files of motr traces in support bundle
            latest_files = RGWSupportBundle._get_latest_files(motr_trace_dir)
            for file in latest_files:
                infile = os.path.join(motr_trace_dir, file)
                tmp_motr_trace_dir = os.path.join(RGWSupportBundle._tmp_src, 'motr_trace_files')
                os.makedirs(tmp_motr_trace_dir, exist_ok=True)
                outfile = os.path.join(tmp_motr_trace_dir, file)
                # Convert m0trace file to human readable yaml format
                SimpleProcess(f'm0trace -i {infile} -Y -o {outfile}.yaml').run()
                SimpleProcess(f'xz {outfile}.yaml').run() # compress the output file

        if stacktrace:
            from subprocess import check_output
            process = '/usr/bin/radosgw'
            pid = check_output(['pidof', process]).decode('utf-8').split('\n')[0]
            stacktrace_file = os.path.join(RGWSupportBundle._tmp_src, 'rgw_live_callstack.log')
            # Collecting running RGW process stack trace using GDB
            cmd = """gdb --batch --quiet -ex "thread apply all bt full" """\
                f"""-ex "quit" {process} {pid}"""
            Log.info(f"generating stack trace for {process} with pid {pid}")
            output, err, _ = SimpleProcess(cmd).run()
            with open(stacktrace_file, 'wb') as fd:
                if output:
                    fd.write(output)
                else:
                    msg = f"Failed to generate Stacktrace! {err}"
                    Log.info(msg)
                    fd.write(msg.encode())

        # copy ceph crash-dump files
        if coredumps:
            crash_dump_dir = os.path.join(log_dir, 'rgw_debug')
            dest_dump_dir = os.path.join(RGWSupportBundle._tmp_src, 'rgw_debug')
            if os.path.exists(crash_dump_dir):
                if size_limit:
                    # get latest 2 core dumps
                    latest_cores = RGWSupportBundle._get_latest_files(
                        directory=crash_dump_dir, number_of_files=2)
                    if len(latest_cores) == 2:
                        remaining_size = RGWSupportBundle._get_remaining_folder_size(
                            RGWSupportBundle._tmp_src, size_limit)
                        # check if sum of both cores is less than remaining size else collect only one
                        sum_of_core_size = os.path.getsize(
                            os.path.join(crash_dump_dir,latest_cores[0])) + \
                            os.path.getsize(
                                os.path.join(crash_dump_dir,latest_cores[1]))
                        # select only one core if both cores exceed the size limit
                        if sum_of_core_size > int(remaining_size[:-1]):
                            latest_cores.pop()
                        if not os.path.exists(dest_dump_dir):
                            os.mkdir(dest_dump_dir)
                    for file_name in latest_cores:
                        shutil.copyfile(os.path.join(crash_dump_dir, file_name),
                            os.path.join(dest_dump_dir, file_name))
                else:
                    shutil.copytree(crash_dump_dir, dest_dump_dir)

        # add cortx components rpm version
        cmd = "rpm -qa | grep cortx"
        output, _, rc = SimpleProcess(cmd).run()
        if rc == 0:
            infile = os.path.join(RGWSupportBundle._tmp_src, 'cortx-rpms')
            with open(infile, 'w') as fin:
                fin.write(output.decode("utf-8"))
        RGWSupportBundle._generate_tar(bundle_id, target_path)
        RGWSupportBundle._cleanup()

    @staticmethod
    def _get_remaining_folder_size(directory:str, size_limit:str) -> str:
        """Returns size of directory in bytes. eg '3B', '100B', '0B'."""
        current_size = 0
        for path, _, files in os.walk(directory):
            for file in files:
                file_path = os.path.join(path, file)
                current_size += os.path.getsize(file_path)
        size_limit_in_byte = FilterLog._get_size_in_bytes(size_limit)
        remaining_size_in_byte = size_limit_in_byte - current_size
        if remaining_size_in_byte < 0:
            return '0B'
        else:
            return str(remaining_size_in_byte) + 'B'

    @staticmethod
    def _get_latest_files(directory:str,number_of_files:int=5) -> list:
        all_files = filter(lambda f: os.path.isfile(os.path.join(directory, f)),
            os.listdir(directory))
        # sort the files based on last modification time
        sorted_files = sorted(all_files,
            key=lambda f: os.path.getmtime(os.path.join(directory, f)),
            reverse=True)
        return sorted_files[0:number_of_files]

    @staticmethod
    def _generate_tar(bundle_id: str, target_path: str):
        """ Generate tar.gz file at given path """
        target_path = os.path.join(target_path, COMPONENT_NAME)
        tar_name = COMPONENT_NAME + '_' + bundle_id + '.tar.gz'
        tar_file_name = os.path.join(target_path, tar_name)
        if not os.path.exists(target_path):
            os.makedirs(target_path)
        with tarfile.open(tar_file_name, 'w:gz') as tar:
            tar.add(RGWSupportBundle._tmp_src,
                arcname=os.path.basename(RGWSupportBundle._tmp_src))

    @staticmethod
    def _cleanup():
        """Cleanup of temporary files generated during rgw support bundle."""
        shutil.rmtree(RGWSupportBundle._tmp_src)

    @staticmethod
    def parse_args():
        parser = argparse.ArgumentParser(description='''Bundle RGW logs.''')
        parser.add_argument('-b', dest='bundle_id', required=True,
            help='Unique bundle id')
        parser.add_argument('-t', dest='path', help='Path to store the created bundle',
            nargs='?', default="/var/cortx/support_bundle/")
        parser.add_argument('-c', dest='cluster_conf',\
            help="Cluster config file path for Support Bundle",\
            default='yaml:///etc/cortx/cluster.conf')
        parser.add_argument('-s', '--services', dest='services', nargs='+',\
            default='', help='List of services for Support Bundle')
        parser.add_argument('-d', '--duration', default='P5D', dest='duration',
            help="Duration - duration for which log should be captured, Default - P5D")
        parser.add_argument('--size_limit', default='500MB', dest='size_limit',
            help="Size Limit - Support Bundle size limit per node, Default - 500MB")
        parser.add_argument('--binlogs', type=RGWSupportBundle.str2bool, default=False, dest='binlogs',
            help="Include/Exclude Binary Logs, Default = False")
        parser.add_argument('--coredumps', type=RGWSupportBundle.str2bool, default=False, dest='coredumps',
            help="Include/Exclude Coredumps, Default = False")
        parser.add_argument('--stacktrace', type=RGWSupportBundle.str2bool, default=False, dest='stacktrace',
            help="Include/Exclude stacktrace, Default = False")
        parser.add_argument('--modules', dest='modules',
            help="list of components & services to generate support bundle.")
        parser.add_argument('--all', type=RGWSupportBundle.str2bool, default=False,
            help="Include/Exclude all debug data, including logs, config, stack"
             + " traces, core dumps, binaries, etc, possibly resulting"
             + " in much HEAVIER support bundle, Default = False")

        args=parser.parse_args()
        return args

    @staticmethod
    def str2bool(value):
        if isinstance(value, bool):
            return value
        if value.lower() in ('true'):
            return True
        elif value.lower() in ('false'):
            return False
        else:
            raise argparse.ArgumentTypeError('Boolean value expected.')

    @staticmethod
    def initialize_logging(cluster_conf):
        """Initialize Logging."""
        cortx_config_store = MappedConf(cluster_conf)
        log_path = cortx_config_store.get(LOG_PATH_KEY)
        if log_path is None:
            raise SupportBundleError(errno.EINVAL, 'Log path is None.')
        log_path = os.path.join(log_path, COMPONENT_NAME, Conf.machine_id)
        os.makedirs(log_path, exist_ok=True)
        Log.init(f'{COMPONENT_NAME}_support_bundle', log_path)

def main():
    args = RGWSupportBundle.parse_args()
    RGWSupportBundle.initialize_logging(args.cluster_conf)

    if args.all:
        binlogs = coredumps = stacktrace = True
    else:
        binlogs = args.binlogs
        coredumps = args.coredumps
        stacktrace = args.stacktrace

    RGWSupportBundle.generate(
        bundle_id=args.bundle_id,
        target_path=args.path,
        cluster_conf=args.cluster_conf,
        duration = args.duration,
        size_limit = args.size_limit,
        binlogs = binlogs,
        coredumps = coredumps,
        stacktrace = stacktrace
    )


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt as e:
        print(f"\n\nWARNING: User aborted command. Partial data " \
            f"save/corruption might occur. It is advised to re-run the" \
            f"command. {e}")
        sys.exit(1)
